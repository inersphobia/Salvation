<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="TriTime">
<meta name="theme-color" content="#000000">
<title>Triangle Time Dials</title>
<link rel="manifest" href="manifest.json">
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
<link rel="apple-touch-icon" href="icon-192.png">
<style>
  body { 
    margin: 0; 
    background: black; 
    overflow: hidden; 
    touch-action: manipulation;
  }
  canvas { 
    display: block;
    position: absolute;
    top: 0;
    left: 0;
  }
  #canvasStatic { z-index: 1; }
  #canvasAnim { z-index: 2; }

  /* --- BASE UI (Desktop/Laptop default) --- */
  #ui {
    position: fixed;
    bottom: 12px;
    width: 100%;
    text-align: center;
    font-family: system-ui, sans-serif;
    z-index: 20;
  }

  #ui button {
    margin: 4px;
    padding: 10px 18px;
    font-size: 15px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    color: white;
    touch-action: manipulation;
    transition: box-shadow 0.15s;
  }

  /* BUTTON COLORS */
  #btnStart  { background:#0074ff; }
  #btnPause  { background:#f28b02; }
  #btnReset  { background:#e03131; }
  #btnFinish { background:#666666; }
  #btnMode   { background:#5b3fd6; }
  #btnRes    { background:#008b8b; }

  /* --- TRUE MOBILE BIG BUTTONS --- */
  /* This is the reliable fix: phones only, never laptops */
  @media screen and (max-device-width: 600px) {
    #ui {
      bottom: 12px;
    }

    #ui button {
      padding: 12px 20px;
      font-size: 16px;
      margin: 6px;
      border-radius: 8px;
    }

    #ui button.pulse {
      box-shadow: 0 0 20px rgba(255,255,255,0.8);
    }
  }

  /* Desktop/laptop pulse (light) */
  #ui button.pulse {
    box-shadow: 0 0 16px rgba(255,255,255,0.6);
  }

  /* Install prompt styling */
  #installPrompt {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 116, 255, 0.95);
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-family: system-ui, sans-serif;
    font-size: 14px;
    z-index: 100;
    display: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  #installPrompt button {
    background: white;
    color: #0074ff;
    border: none;
    padding: 6px 16px;
    border-radius: 4px;
    margin-left: 12px;
    cursor: pointer;
    font-weight: 600;
  }
</style>
</head>
<body>

<canvas id="canvasStatic"></canvas>
<canvas id="canvasAnim"></canvas>

<div id="installPrompt">
  <span>Install Triangle Timer as an app?</span>
  <button id="installBtn">Install</button>
  <button id="dismissBtn" style="background:#666;">Not now</button>
</div>

<div id="ui">
  <button id="btnStart">START</button>
  <button id="btnPause">PAUSE</button>
  <button id="btnReset">RESET</button>
  <button id="btnFinish">FINISH</button>
  <button id="btnMode">81-MIN</button>
  <button id="btnRes">CORNERS</button>
</div>

<script>
/* ---------- CONFIG ---------- */
const numDials = 7;
let fastMode = false;
let ledRes = 0;

const dotsPerEdge = [1,2];
const baseIntervals = [4860,1620,540,180,60,20,20/3];
const baseTicks     = [27*60,9*60,3*60,60,20,20/3,20/9];

let intervals=[], ticks=[], totalCycle=0;

const WORLD_RADIUS = 6;
let scaleF = 60;

let dialPos=[], dialAngle=[], starLines=[];
let triVerts=[], ledPath=[], activeIdx=[];

let centerColor=[], centerSize=[], glowAlpha=[];

let running=false, finished=false;
let startMs=0, pauseMs=0;
let timerStr="0000:000₃";
let overtimeStart=0; // When overtime counting began

/* Wake Lock */
let wakeLock = null;

/* canvas - dual layer system */
const canvasStatic = document.getElementById("canvasStatic");
const canvasAnim = document.getElementById("canvasAnim");
const ctxStatic = canvasStatic.getContext("2d");
const ctx = canvasAnim.getContext("2d");

/* ---------- 30 FPS THROTTLE ---------- */
let targetFPS=30;
let frameInterval=1000/targetFPS;
let lastFrameTime=0;

/* BUTTONS */
const btnStart=document.getElementById("btnStart");
const btnPause=document.getElementById("btnPause");
const btnReset=document.getElementById("btnReset");
const btnFinish=document.getElementById("btnFinish");
const btnMode=document.getElementById("btnMode");
const btnRes=document.getElementById("btnRes");

/* ---------- HAPTICS ---------- */
function haptic(duration=35){
  if (navigator.vibrate){
    navigator.vibrate(duration);
  }
}

/* ---------- BUTTON PULSE ---------- */
function pulseButton(btn){
  btn.classList.add("pulse");
  setTimeout(()=>btn.classList.remove("pulse"), 150);
  haptic(35);
}

/* ---------- WAKE LOCK ---------- */
async function requestWakeLock(){
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake Lock acquired');
    }
  } catch (err) {
    console.log('Wake Lock failed:', err.message);
  }
}

function releaseWakeLock(){
  if (wakeLock !== null) {
    wakeLock.release()
      .then(() => {
        wakeLock = null;
        console.log('Wake Lock released');
      });
  }
}

/* ---------- COMPLETION TONE ---------- */
function playCompletionTone(){
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create a pleasant two-tone chime
    const playTone = (freq, startTime, duration) => {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = freq;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0, startTime);
      gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
      
      oscillator.start(startTime);
      oscillator.stop(startTime + duration);
    };
    
    const now = audioContext.currentTime;
    playTone(523.25, now, 0.3);        // C5
    playTone(659.25, now + 0.15, 0.4); // E5
    playTone(783.99, now + 0.3, 0.5);  // G5
    
  } catch (err) {
    console.log('Audio playback failed:', err);
  }
}

/* ---------- RESPONSIVE SCALING ---------- */
let needsStaticRedraw = true;

function resizeCanvas(){
  const w = window.innerWidth;
  const h = window.innerHeight;
  
  canvasStatic.width = canvasAnim.width = w;
  canvasStatic.height = canvasAnim.height = h;

  scaleF = Math.min(
    (h * 0.33) / WORLD_RADIUS,
    (w * 0.45) / WORLD_RADIUS
  );
  
  needsStaticRedraw = true;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ---------- TABLES ---------- */
function updateTables(){
  const m=fastMode?3:1;
  intervals = baseIntervals.map(v=>v/m);
  ticks     = baseTicks.map(v=>v/m);
  totalCycle = intervals[0];
}

/* ---------- UTILS ---------- */
function worldToScreen(x,y){
  return {
    x: x*scaleF + canvasAnim.width/2,
    y: -y*scaleF + canvasAnim.height/2 - 40
  };
}

function posIndex(i,elapsed){
  if (elapsed<0) elapsed=0;
  const T=ticks[i];
  return (Math.floor(elapsed/T)%3)+1;
}

/* ---------- GEOMETRY ---------- */
function setupGeometry(){
  dialPos=[]; dialAngle=[]; starLines=[];

  for (let i=0;i<numDials;i++){
    const adj=(i-6+numDials)%numDials;
    const ang=adj*2*Math.PI/7 + Math.PI/2;
    const x=4.5*Math.cos(ang);
    const y=4.5*Math.sin(ang);

    dialPos.push({x,y});
    dialAngle.push(ang);
  }

  const R=6;
  for (let i=0;i<numDials;i++){
    const adj1=(i-6+numDials)%numDials;
    const a1=adj1*2*Math.PI/7 + Math.PI/2;
    const x1=R*Math.cos(a1), y1=R*Math.sin(a1);

    const j=(i+2)%numDials;
    const adj2=(j-6+numDials)%numDials;
    const a2=adj2*2*Math.PI/7 + Math.PI/2;
    const x2=R*Math.cos(a2), y2=R*Math.sin(a2);

    starLines.push({x1,y1,x2,y2});
  }
}

function setupTriangles(){
  triVerts=[];
  const h=1.0, w=1.15;

  for (let i=0;i<numDials;i++){
    const C=dialPos[i];
    const ang=dialAngle[i];

    const local=[
      {x:0, y:h},
      {x:w, y:-h*0.45},
      {x:-w,y:-h*0.45}
    ];

    const rot=ang - Math.PI/2;
    const c=Math.cos(rot), s=Math.sin(rot);

    const verts=local.map(v=>({
      x:v.x*c - v.y*s + C.x,
      y:v.x*s + v.y*c + C.y
    }));

    triVerts.push(verts);
  }
}

/* ---------- LED PATHS ---------- */
function buildLedPaths(){
  ledPath=[]; activeIdx=[];

  for (let i=0;i<numDials;i++){
    let pts=[];
    const V=triVerts[i];

    if (ledRes===0){
      // CORNERS mode
      pts=[V[0],V[1],V[2]];
    }
    else {
      // HALF mode
      const mid=(a,b)=>({x:(a.x+b.x)/2, y:(a.y+b.y)/2});
      pts=[
        V[0], mid(V[0],V[1]),
        V[1], mid(V[1],V[2]),
        V[2], mid(V[2],V[0])
      ];
    }

    ledPath.push(pts);
    activeIdx.push(0);
  }
}

function updateLedPosition(i,elapsed){
  const path=ledPath[i];
  const T=ticks[i];
  const pos=posIndex(i,elapsed);
  const frac=(elapsed%T)/T;

  const posFrac=(pos-1)/3;
  const total=(posFrac + frac/3) % 1;

  let idx=Math.floor(total*path.length);
  if (idx>=path.length) idx=path.length-1;

  activeIdx[i]=idx;
}

/* ---------- TIMER TEXT ---------- */
function updateTimerText(el){
  let minsIdx, fracIdx;

  if (fastMode){
    minsIdx=[0,1,2];
    fracIdx=[3,4,5,6];
  } else {
    minsIdx=[0,1,2,3];
    fracIdx=[4,5,6];
  }

  const m=minsIdx.map(i=>posIndex(i,el)-1).join("");
  const f=fracIdx.map(i=>posIndex(i,el)-1).join("");
  timerStr=m+":"+f+"₃";
}

function updateOvertimeText(el){
  // Use dial positions 4-0 (1min, 3min, 9min, 27min, 81min)
  const digits = [4,3,2,1,0].map(i => posIndex(i, el) - 1).join("");
  timerStr = "+" + digits + "₃";
}

/* ---------- CLOCK CONTROL ---------- */
function startClock(){
  if (running) return;
  if (finished) resetClock();
  startMs = pauseMs>0 ? performance.now()-pauseMs : performance.now();
  running=true;
  requestWakeLock();
}
function pauseClock(){
  if (!running||finished) return;
  running=false;
  pauseMs=performance.now()-startMs;
  releaseWakeLock();
}
function resetClock(){
  running=false; finished=false;
  pauseMs=0; startMs=performance.now();
  overtimeStart=0;
  buildLedPaths();
  centerColor=Array(numDials).fill("white");
  centerSize =Array(numDials).fill(8);
  glowAlpha =Array(numDials).fill(0);
  updateTimerText(0);
  needsStaticRedraw = true;
  releaseWakeLock();
}
function finishClock(){
  finished=true;
  running=false;
  overtimeStart=performance.now();
  updateTimerText(totalCycle);
  playCompletionTone();
  releaseWakeLock();
}

function toggleMode(){
  if (running || finished) return;
  fastMode=!fastMode;
  btnMode.textContent=fastMode? "27-MIN" : "81-MIN";
  updateTables();
  resetClock();
  needsStaticRedraw = true;
}

function toggleRes(){
  if (running || finished) return;
  ledRes=(ledRes+1)%2;
  btnRes.textContent=["CORNERS","HALF"][ledRes];
  buildLedPaths();
  resetClock();
  needsStaticRedraw = true;
}

/* ---------- DRAW HELPERS ---------- */
function drawStaticLayer(){
  ctxStatic.clearRect(0, 0, canvasStatic.width, canvasStatic.height);
  
  // Draw star lines on static canvas
  ctxStatic.lineWidth = 3;
  ctxStatic.strokeStyle = "#00bfff";
  for (let s of starLines){
    let a = worldToScreen(s.x1, s.y1);
    let b = worldToScreen(s.x2, s.y2);
    ctxStatic.beginPath();
    ctxStatic.moveTo(a.x, a.y);
    ctxStatic.lineTo(b.x, b.y);
    ctxStatic.stroke();
  }
  
  needsStaticRedraw = false;
}

function drawStarLines(){
  // Star lines are now on static layer - this function kept for compatibility
  // but does nothing (drawing happens in drawStaticLayer)
}

function drawCenterDots(now){
  if (finished){
    const t=now/1000;
    for (let i=0;i<numDials;i++){
      centerSize[i]=8+4*(0.5+0.5*Math.sin(t*1.5));
      glowAlpha[i]=0.15 + 0.15*(0.5+0.5*Math.sin(t*1.5+i*0.3));
    }
  }

  for (let i=0;i<numDials;i++){
    const C=dialPos[i];
    const p=worldToScreen(C.x,C.y);

    let ga=glowAlpha[i];
    if (ga>0.01){
      const r=0.6*scaleF;
      let g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r);
      g.addColorStop(0,`rgba(255,255,255,${ga})`);
      g.addColorStop(1,"rgba(255,255,255,0)");
      ctx.fillStyle=g;
      ctx.beginPath();
      ctx.arc(p.x,p.y,r,0,Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle=
      centerColor[i]==="blue"   ? "rgb(0,120,255)" :
      centerColor[i]==="orange" ? "rgb(255,160,0)" :
      centerColor[i]==="red"    ? "rgb(255,70,70)" :
                                  "white";

    ctx.beginPath();
    ctx.arc(p.x,p.y,centerSize[i],0,Math.PI*2);
    ctx.fill();
  }
}

function drawLEDs(){
  ctx.fillStyle="white";
  for (let i=0;i<numDials;i++){
    const idx=activeIdx[i];
    const P=ledPath[i][idx];
    const s=worldToScreen(P.x,P.y);
    ctx.beginPath();
    ctx.arc(s.x,s.y,6,0,Math.PI*2);
    ctx.fill();
  }
}

function drawTimerText(){
  ctx.fillStyle = finished ? "#ff9500" : "white";
  ctx.font = canvasAnim.width < 500 ? "32px monospace" : "40px monospace";
  ctx.textAlign="center";
  ctx.fillText(timerStr, canvasAnim.width/2, canvasAnim.height/2 - 40);
}

/* ---------- MAIN DRAW LOOP ---------- */
function draw(now){
  if (now-lastFrameTime < frameInterval){
    requestAnimationFrame(draw); return;
  }
  lastFrameTime=now;

  // Only redraw static layer when needed (resize, mode change, etc)
  if (needsStaticRedraw) {
    drawStaticLayer();
  }

  // Clear only the animation canvas (not the static background)
  ctx.clearRect(0, 0, canvasAnim.width, canvasAnim.height);

  const elapsed = running ? (now-startMs)/1000 : pauseMs/1000;

  if (running){
    updateTimerText(elapsed);

    if (elapsed>=totalCycle && !finished) finishClock();
  }
  
  // Continue animations even when finished (overtime mode)
  if (running || finished) {
    const animTime = finished ? (now - overtimeStart)/1000 + totalCycle : elapsed;
    
    for (let i=0;i<numDials;i++){
      updateLedPosition(i, animTime);
      const p=posIndex(i, animTime);
      centerColor[i] =
        p===1 ? "blue" :
        p===2 ? "orange" : "red";
    }
  }
  
  // Handle overtime display when finished
  if (finished){
    const overtime = (now - overtimeStart) / 1000;
    updateOvertimeText(overtime);
  }

  // Draw only animated elements
  drawCenterDots(now);
  drawLEDs();
  drawTimerText();

  requestAnimationFrame(draw);
}

/* ---------- TOUCH GESTURES ---------- */
let tapTimer=null;

canvasAnim.addEventListener("touchstart", e=>{
  e.preventDefault();

  if (tapTimer==null){
    tapTimer=setTimeout(()=>{
      tapTimer=null;
      running? pauseClock() : startClock();
      haptic(30);
    },180);
  } else {
    clearTimeout(tapTimer);
    tapTimer=null;
    resetClock();
    haptic(40);
  }
}, {passive:false});

/* ---------- PWA INSTALL PROMPT ---------- */
let deferredPrompt;
const installPrompt = document.getElementById('installPrompt');
const installBtn = document.getElementById('installBtn');
const dismissBtn = document.getElementById('dismissBtn');

window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installPrompt.style.display = 'block';
});

installBtn.addEventListener('click', async () => {
  if (deferredPrompt) {
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    deferredPrompt = null;
    installPrompt.style.display = 'none';
  }
});

dismissBtn.addEventListener('click', () => {
  installPrompt.style.display = 'none';
  deferredPrompt = null;
});

/* ---------- SERVICE WORKER REGISTRATION ---------- */
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('Service Worker registered'))
      .catch(err => console.log('Service Worker registration failed:', err));
  });
}

/* ---------- WAKE LOCK RE-ACQUIRE ON VISIBILITY CHANGE ---------- */
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible' && running) {
    await requestWakeLock();
  }
});

/* ---------- INIT ---------- */
updateTables();
setupGeometry();
setupTriangles();
buildLedPaths();

centerColor=Array(numDials).fill("white");
centerSize =Array(numDials).fill(8);
glowAlpha =Array(numDials).fill(0);
updateTimerText(0);

// Draw static layer once on init
drawStaticLayer();

/* ---------- BUTTON HOOKS ---------- */
btnStart.onclick = ()=>{ pulseButton(btnStart); startClock(); };
btnPause.onclick = ()=>{ pulseButton(btnPause); pauseClock(); };
btnReset.onclick = ()=>{ pulseButton(btnReset); resetClock(); };
btnFinish.onclick= ()=>{ pulseButton(btnFinish); finishClock(); };
btnMode.onclick  = ()=>{ pulseButton(btnMode); toggleMode(); };
btnRes.onclick   = ()=>{ pulseButton(btnRes); toggleRes(); };

requestAnimationFrame(draw);
</script>

</body>
</html>
